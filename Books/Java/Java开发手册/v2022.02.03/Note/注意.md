# 编程规约

## 命名风格

07. 抽象类 以 Abstract 或 Base 开头
    - 异常类以 Exception 结尾
    - 测试类以 Test 结尾

09. boolean 变量不加 is 前缀

10. 包名小写
    - 每一级只允许一个单词
    - 单数形式

12. 避免不规范的英文缩写

18. 枚举名带 Enum 后缀
    - 枚举成员名 大写, 单词间下划线分隔

19. Service 等接口层方法命名
    - 获取多个对象
        - list 前缀
        - 复数结尾
        - 举例: listObjects
    - 获取对象数量
        - count 前缀
        - 举例: countObject

## OOP 规约

07. Integer 判等也应使用 equals 方法
    - IntegerCache 外的 Integer 判等相当于 引用判等
    - Objects.equals

08. 货币类型均存储
    - 以最小单位存储
    - 整形

09. 浮点数判等
    - 方式1: Math.abs
    - 方式2: BigDecimal.compareTo

10. BigDecimal 判等
    - 使用 compareTo 而非 equals
        - compareTo 忽略精度 (1.0 等价于 1.00)
        - equals 不忽略精度 (1.0 不等价于 1.00)

12. BigDecimal 不能直接由 float 或 double 构造
    - 方式1: String 构造
    - 方式2: BigDecimal.valueOf 创建

13. POJO 属性字段要使用 包装类型, 由使用方进行 空引用 校验
    - 避免 空引用 与 默认值 含义冲突

14. POJO 的 默认属性值 设置
    - 应该在逻辑方设置, 而不是在 POJO 类定义中设置
        - 避免逻辑中对默认值的要求不一致

16. 构造方法中不应有初始化逻辑, 初始化逻辑应该在单独的初始化方法中

17. POJO 必须实现 toString()
    - 如果有基类, 必须先调用 super.toString()

18. 同一属性, 禁止同时存在 isA() 与 getA() 方法

19. String.split 字符串分隔多元素时, 校验元素数量
    - 如果有相邻的分隔符, 结果数组长度将小于 `分隔符数量-1`

20. 多个构造, 或多个同名方法, 放在一起, 便于阅读

21. 类内方法顺序
    01. public
    02. protected
    03. private
    04. getter / setter

22. setter 方法
    - 参数名与字段名一致
    - 方法内只赋值, 没逻辑

23. 在循环中拼接字符串, 应显示提前创建 StringBuilder
    - 避免在循环中 隐式 多次 创建 StringBuilder

24. 能用 final 时尽量用 final
    - 包括局部变量
    - final 类
    - final 方法

## 时期时间

01. pattern 中 应使用 y 而非 Y
    - yyyy 与 YYYY 含义不同
    - Y 的含义指当前周属于哪一年, 误用会存在跨年问题

02. 月 M
    - 分 m
    - 时
        - 24: H
        - 12: h

03. 时刻及时间差处理 使用 Instant 类

04. 禁用的 时间 API
    - java.sql.Date
        - API 需要自己处理异常
    - java.sql.Time
        - 继承自 java.sql.Date
        - 容易误用, 不易做异常处理
    - java.sql.Timestamp
        - 继承自 java.sql.Date
        - 误用构造可能抛异常
        - time 与 nanos 容易误解误用

05. 闰年等时间问题 使用 LocalDate 等新的时间API处理, 而不是 Calendar

06. 时间逻辑不要绑定具体的日期数值, 避免 `后一年没有2月29日` 等问题

07. 月份使用枚举
    - Date 和 Calendar 等API获取月份数值为 0~11, 容易误用

## 集合处理

01. hashcode 和 equals 必须同时重写
    - 需要用 Set, Map 存储的类, 必须实现 hashcode 和 equals

02. 使用 isEmpty 判空, 而不是 size == 0

03. ~~使用 Collectors.toMap 需要指定 mergeFunction, 避免 key冲突时抛异常~~
    - 甚至可指定用什么类型的 map

04. Collectors.toMap 可能导致 NPE
    - why
        - Collectors.toMap 会调用 Map.merge
        - Map.merge 不支持 null value, 否则 NPE
            - 为什么不支持 null value
                - null value 在 merge 中的语义为 remove
                - 如果允许 null value 存在, 将于 remove 逻辑冲突
    - how to solve
        - 使用 `Stream.<R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);`

        - 或者在 Collectors.toMap 中传入 value getter 时进行 null value 处理
            - **`不推荐`**

相关问题 - 如何判断 Map 是否支持 null value
* HashMap 等非线程安全的 Map 支持 null value
    - HashTable, ConcurrentHashMap 等线程安全的 Map 不支持 null value
    - 因为 null value 与 not contains Key 存在二义性
* 对 null key 的支持情况 同理

05. ArrayList.subList 返回值类型是 SubList, 而不是 ArrayList
    - 返回的 SubList 为原数据视图, 对视图的操作对原数据有效
    - 而且尽可能避免针对集合具体类型编程

08. 不可同时对 SubList 及其父集合 进行 遍历操作或增删操作
    - 因为 SubList 是镜像, 不是副本, 所以可能引起并发修改异常

09. ArrayList toArray(new T[0])

    ```java
    // class ArrayList
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // Make a new array of a's runtime type, but my contents:
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
    ```

12. 泛型 PECS 原则 (Producer Extends Consumer Super)
    - 生产具体的
    - 消费抽象的

15. 实现 Comparator 一定要处理相等的情况, 以保证比较相关的数学运算性质
    - 互反性
    - 传递性
    - 等价替换性

17. 集合初始化时, 尽可能指定容量大小, 避免频繁扩容 (数据越多影响越大)

18. 先遍历 Map.keySet 再 Map.get 相当于 1次遍历 + N次查找
    - 可以替换成遍历 entrySet, 或 Map.forEach

19. 对 Map 的 key 与 value 可否为 null 的总结

<table>
<tr> <th> class </th>               <th> key nullable </th> <th> value nullable </th>   <th> super </th>        <th> thread-safe </th> </tr>
<tr> <td> HashTable </td>           <td> No </td>           <td> No </td>               <td> Dictionary </td>   <td> synchronized </td> </tr>
<tr> <td> ConcurrentHashMap </td>   <td> No </td>           <td> No </td>               <td> AbstractMap </td>  <td> sync on table element </td> </tr>
<tr> <td> HashMap </td>             <td> Yes </td>          <td> Yes </td>              <td> AbstractMap </td>  <td> not thread-safe </td> </tr>
<tr> <td> TreeMap </td>             <td> No </td>           <td> Yes </td>              <td> AbstractMap </td>  <td> not thread-safe </td> </tr>
</table>

20. 集合的 有序性 sort 和 稳定性 order
    - 稳定性: 每次遍历, 次序相同
    - ArrayList: unsort, order
    - HashSet: unsort, unorder
    - TreeSet: sort, order

---
